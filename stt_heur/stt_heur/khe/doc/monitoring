@Chapter
    @Title { Solution Monitoring }
    @Tag { monitoring }
@Begin
@LP
As a solution changes, it is continuously @I monitored by a
hand-tuned constraint network.
@BeginSections

@Section
    @Title { Measuring cost }
    @Tag { monitoring.cost }
@Begin
@LP
KHE measures the badness of a solution as a single integral value
called the @I { cost }, or sometimes the @I { combined cost }
because it includes the cost of both hard and soft constraint
deviations.  Storing costs in this way is convenient, because it
allows costs to be assigned using @C { = }, added using @C { + },
and compared using @C { < } and so on in the usual way.  The hard
cost is shifted left by 32 bits, to ensure that it is more
significant than any reasonable total soft cost, then added
to the soft cost.
@PP
The type of a combined cost is @C { KHE_COST }, a synonym for
the standard C 64-bit integer type @C { int64_t } (a fact best
forgotten).  To find the current combined cost of a solution, call
@ID @C {
KHE_COST KheSolnCost(KHE_SOLN soln);
}
This value is stored explicitly in @C { soln }, so this function
takes virtually no time to execute.  To create a combined cost,
call function
@ID @C {
KHE_COST KheCost(int hard_cost, int soft_cost);
}
Given a combined cost, its two components may be accessed by
@ID @C {
int KheHardCost(KHE_COST combined_cost);
int KheSoftCost(KHE_COST combined_cost);
}
There is also the constant
@ID @C {
KheCostMax
}
which returns the maximum value storable in a variable of
type @C { KHE_COST } (a synonym for @C { INT64_MAX }) and
the function
@ID @C {
int KheCostCmp(KHE_COST cost1, KHE_COST cost2);
}
which returns an @C { int } which is less than, equal to, or
greater than zero if the first argument is respectively less
than, equal to, or greater than the second, as needed when
sorting items by cost.  The implementation does not make the
mistake of merely subtracting @C { cost2 } from @C { cost1 };
the result then would be a @C { KHE_COST } which will usually
overflow the @C { int } result.
@PP
The suggested way to display a combined cost is as a decimal
number with the hard cost before the decimal point and the
soft cost after.  Four decimal places are displayed, allowing
for soft costs up to 9999.  Larger soft costs are displayed
as 9999.  To assist with this, function
@ID @C {
double KheCostShow(KHE_COST combined_cost);
}
returns a value which, when printed with @C { printf } format
@C { "%.4f" }, prints the cost in this format.
@PP
These functions assume that both components of the cost are
non-negative.  There is no problem with negative combined
costs in themselves, but when a hard and soft cost are
combined together, if either is negative they may be
different if they are separated again.
@End @Section

@Section
    @Title { Monitors }
    @Tag { monitoring_monitors }
@Begin
@LP
A @I { monitor } is an object, of type @C { KHE_MONITOR }, that
monitors one part of a solution.  Monitors contain back pointers
accessed by operations
@ID @C {
void KheMonitorSetBack(KHE_MONITOR m, void *back);
void *KheMonitorBack(KHE_MONITOR m);
}
as usual.  Operations
@ID @C {
KHE_SOLN KheMonitorSoln(KHE_MONITOR m);
int KheMonitorIndexInSoln(KHE_MONITOR m);
KHE_COST KheMonitorCost(KHE_MONITOR m);
}
return the enclosing solution, the index of @C { m } in that
solution, and the cost of whatever @C { m } is monitoring,
kept up to date by KHE as the solution changes.  For example,
an assign time monitor monitors one point of application of
one assign time constraint (one event).  Its cost is the value
of the cost function of its constraint applied to a number of
deviations which is the total duration of meets derived from its
event which are not assigned a time.
@PP
Functions
@ID @C {
int KheSolnMonitorCount(KHE_SOLN soln);
KHE_MONITOR KheSolnMonitor(KHE_SOLN soln, int i);
}
return the number of monitors currently monitoring @C { soln }, and the
@C { i }th of those monitors.  Although KHE does not fully specify the
order in which these monitors appear, it does guarantee that the monitors
which monitor constraints will appear together in the list in the order
that their constraints appear in the input.  It is best to select these
monitors by testing whether the result of @C { KheMonitorConstraint }
below is non-@C { NULL }.
@PP
Type @C { KHE_MONITOR } is the abstract supertype of many
concrete subtypes.  Each monitor object contains a tag field
identifying its subtype, returned by
@ID @C {
KHE_MONITOR_TAG KheMonitorTag(KHE_MONITOR m);
}
Type @C { KHE_MONITOR_TAG } is
@ID @C {
typedef enum {
  KHE_ASSIGN_RESOURCE_MONITOR_TAG,
  KHE_ASSIGN_TIME_MONITOR_TAG,
  KHE_SPLIT_EVENTS_MONITOR_TAG,
  KHE_DISTRIBUTE_SPLIT_EVENTS_MONITOR_TAG,
  KHE_PREFER_RESOURCES_MONITOR_TAG,
  KHE_PREFER_TIMES_MONITOR_TAG,
  KHE_AVOID_SPLIT_ASSIGNMENTS_MONITOR_TAG,
  KHE_SPREAD_EVENTS_MONITOR_TAG,
  KHE_LINK_EVENTS_MONITOR_TAG,
  KHE_AVOID_CLASHES_MONITOR_TAG,
  KHE_AVOID_UNAVAILABLE_TIMES_MONITOR_TAG,
  KHE_LIMIT_IDLE_TIMES_MONITOR_TAG,
  KHE_CLUSTER_BUSY_TIMES_MONITOR_TAG,
  KHE_LIMIT_BUSY_TIMES_MONITOR_TAG,
  KHE_LIMIT_WORKLOAD_MONITOR_TAG,
  KHE_TIMETABLE_MONITOR_TAG,
  KHE_TIME_GROUP_MONITOR_TAG,
  KHE_ORDINARY_DEMAND_MONITOR_TAG,
  KHE_WORKLOAD_DEMAND_MONITOR_TAG,
  KHE_EVENNESS_MONITOR_TAG,
  KHE_GROUP_MONITOR_TAG,
  KHE_MONITOR_TAG_COUNT
} KHE_MONITOR_TAG;
}
Monitors of the first fifteen types monitor one point of application
of one constraint; their cost is the total cost of deviations at that
point.  They are described in detail in later sections of this chapter.
Monitors of the last five types do not monitor constraints.  Timetable
monitors hold the timetables of resources and events
(Section {@NumberOf monitoring_timetables}); time group monitors are
used within them.  Ordinary and workload demand monitors monitor
matchings, and evenness monitors monitor evenness
(Chapter {@NumberOf matchings}).  Group monitors group
together other monitors (Chapter {@NumberOf grouping}).  The last
value is not a tag; it is a count of the number of monitor types,
allowing code of the form
@ID @C {
for( tag = 0;  tag < KHE_MONITOR_TAG_COUNT;  tag++ )
  ... do something for monitors of type tag ...
}
For those monitors that monitor a point of application of a constraint,
functions
@ID @C {
KHE_CONSTRAINT KheMonitorConstraint(KHE_MONITOR m);
char *KheMonitorAppliesToName(KHE_MONITOR m);
}
return the constraint and the name of the point of application
of the constraint (if the point of application is an event
resource, the name of the enclosing event is returned).  For
other monitors they return @C { NULL }.  Each monitor which
monitors a constraint also has specific functions which return
the specific type of constraint and point of application.
@PP
The cost of a monitor is a function of a set of @I { deviations },
which are non-negative integers.  A deviation could be 0, although
the cost functions all have the property that adding or removing a
0 from a set of deviations does not change the cost.  The deviations
can be obtained by calling
@ID @C {
int KheMonitorDeviationCount(KHE_MONITOR m);
int KheMonitorDeviation(KHE_MONITOR m, int i);
char *KheMonitorDeviationDescription(KHE_MONITOR m, int i);
}
The first two return the number of deviations and the @C { i }th
deviation; the third returns a description of the @C { i }th deviation.
These functions are intended for reporting, not solving, and may be slow.
@PP
Some monitors, such as timetable monitors and group monitors, do not
monitor constraints or calculate deviations, and so they return 0 for
@C { KheMonitorDeviationCount }.  Most monitors have one deviation,
and they return 1 for @C { KheMonitorDeviationCount } and @C { NULL }
for @C { KheMonitorDeviationDescription }.  A few monitors have
multiple deviations:  avoid clashes monitors, which have one deviation
for each time where there is a clash (described by the name of the
time), and limit busy times and spread events monitors, which have
one deviation for each time group monitored (described by the name
of the time group).
@PP
As an aid to debugging, function
@ID { 0.98 1.0 } @Scale @C {
void KheMonitorDebug(KHE_MONITOR m, int verbosity, int indent, FILE *fp);
}
debugs @C { m } onto @C { fp } with the given verbosity and indent.
The output starts with a @C { G }, @F { A } or @F { D } indicating
whether the monitor is a group monitor, an attached non-group monitor,
or a detached non-group monitor (see below for these categories).
This is followed by @C { _ } if the monitor has no parent, @C { S }
if it has a parent and is linked, directly or indirectly, to the
solution object, and @C { U } otherwise.  The debug then continues
with the monitor's tag and cost.  After that comes other information,
depending on the monitor type and verbosity.  There is also
@ID @C {
char *KheMonitorTagShow(KHE_MONITOR_TAG tag);
}
which returns a string representation of @C { tag }.  In practice
a more useful function is
@ID @C {
char *KheMonitorLabel(KHE_MONITOR m);
}
This returns @C { KheMonitorTagShow(KheMonitorTag(m)) } if @C { m }
is not a group monitor (see below), and @C { m }'s subtag label if
@C { m } is a group monitor.
@End @Section

@Section
    @Title { Attaching and detaching }
    @Tag { monitoring.attach }
@Begin
@LP
For a monitor to be updated when the solution changes, there must
be linkages from the appropriate points within the solution to
the monitor.  When these linkages are present, the monitor is
said to be @I { attached to the solution }, or just @I { attached }.
Monitors are attached to begin with, but they can be detached at any
time, and even reattached later, by calling
@ID @C {
void KheMonitorDetachFromSoln(KHE_MONITOR m);
void KheMonitorAttachToSoln(KHE_MONITOR m);
}
Even when detached, a monitor remembers which parts of the solution
it is supposed to monitor, so the attach operation does not have to
tell the monitor where to attach itself.  To find out whether a
monitor is currently attached or detached, call
@ID @C {
bool KheMonitorAttachedToSoln(KHE_MONITOR m);
}
These three operations apply to all kinds of monitors except the
group monitors of Chapter {@NumberOf grouping}, to which the concept
of attachment to the solution does not apply.  Another function,
highly recommended for calling at the end of a solve, is
@ID @C {
void KheSolnEnsureOfficialCost(KHE_SOLN soln);
}
This ensures that all constraint monitors are both attached to the
solution and reporting their cost to the solution, directly or
indirectly via group monitors, and that all demand and evenness
monitors are detached from the solution, guaranteeing that the
solution cost is the official cost.
@PP
While a monitor is detached, it receives no information about changes
to the solution, and, by definition, its cost is 0.  Detaching a
monitor may therefore change its cost.  If there is a change in
cost, it is reported to the monitor's parent (if it has one) as
usual.  Conversely, attaching a monitor brings it up to date with
the current state of the solution, which again may change its cost;
and again, if there is a change in cost it is reported to its parent
(if it has one).
@PP
There are two main reasons for detaching a monitor.  First, the user
might make a deliberate choice to ignore some constraints.  For
example, a solver that works in two phases, first finding a solution
that satisfies the hard constraints, and then attacking the soft ones,
might detach the monitors for the soft constraints during its first
phase.  An example of this kind of deliberate choice is KHE's matching
feature (Chapter {@NumberOf matchings}), which is implemented with
monitors.  Unlike other monitors, matching monitors are detached
initially.  KHE makes this choice deliberately, on the grounds that
the cost of the matching is not officially part of the cost function.
@PP
The second reason for detaching a monitor is that the user may know
that its cost will be zero for a long time.  In that case, detaching
it means that no time is spent keeping it up to date, yet it still
reports the correct cost.  For example, if the meets of one point
of application of a link events constraint are assigned to each
other and the user knows that those assignments will not be removed,
then it is safe to save time by detaching the corresponding monitor.
@PP
This reasoning is embodied in function
@ID @C {
void KheMonitorAttachCheck(KHE_MONITOR m);
}
It assumes that certain elements of the solution will not change
for a long time:  the way that events are split into meets,
non-@C { NULL } assignments to meets that do not lie in nodes,
non-@C { NULL } assignments to follower tasks, and meet and task
domains.  It checks whether, under that assumption, the cost of
monitor @C { m } must be and remain 0.  If so, it detaches @C { m }
unless it is already detached; if not, it attaches @C { m } unless
it is already attached.
@PP
The assumption proves nothing about the future cost of monitors of
most types.  For example, it does not prevent the next time or
resource assignment from producing a clash (except in circumstances
too rare to be worth checking for).  In these cases,
@C { KheMonitorAttachCheck } merely attaches @C { m } if it is not
already attached.  For each monitor type where more is done, the
details are given as part of the description of that monitor type
later in this chapter.
@End @Section

@Section
    @Title { Event monitors }
    @Tag { monitoring.event_monitors }
@Begin
@LP
An @I { event monitor } monitors one or more events.  The set of
monitors (attached or unattached) which monitor a given event may
be found by calling
@ID @C {
int KheEventMonitorCount(KHE_SOLN soln, KHE_EVENT e);
KHE_MONITOR KheEventMonitor(KHE_SOLN soln, KHE_EVENT e, int i);
}
These return the number of monitors that monitor @C { e } in
@C { soln }, and the @C { i }th of these, as usual.  The timetable
monitor for event @C { e } (Section {@NumberOf monitoring_timetables})
is not visited by these functions; it may be retrieved by calling
@C { KheEventTimetableMonitor }.
@PP
The total cost of these monitors measures how well @C { e } is
timetabled.  Functions
@ID @C {
KHE_COST KheEventCost(KHE_SOLN soln, KHE_EVENT e);
KHE_COST KheEventMonitorCost(KHE_SOLN soln, KHE_EVENT e,
  KHE_MONITOR_TAG tag);
}
return the total cost of all the monitors monitoring @C { e },
and the total cost of all monitors monitoring @C { e } of a
specific type, defined by @C { tag }.  @C { KheEventMonitorCost }
returns 0 when @C { tag } does not specify one of the monitor
types in the following subsections.
@PP
Each point of application of a spread events constraint or link
events constraint is one event group, and a monitor of these
kinds is attached to each of the events in its event group.
If @C { KheEventCost(soln, e) } is summed over all events, the
cost of such monitors is counted repeatedly, and the total
may exceed the total cost of all event monitors.
@PP
The following subsections list the various kinds of event
monitors and the details specific to each of them.  Their types
(@C { KHE_ASSIGN_TIME_MONITOR } and so on) may be obtained by
downcasting from @C { KHE_MONITOR } after checking the type tag.
@BeginSubSections

@SubSection
    @Title { Assign time monitors }
@Begin
@LP
An assign time monitor has tag @C { KHE_ASSIGN_TIME_MONITOR_TAG }
and monitors an event which is one point of application of one
assign time constraint.  Functions
@ID @C {
KHE_ASSIGN_TIME_CONSTRAINT KheAssignTimeMonitorConstraint(
  KHE_ASSIGN_TIME_MONITOR m);
KHE_EVENT KheAssignTimeMonitorEvent(KHE_ASSIGN_TIME_MONITOR m);
}
return the assign time constraint and event being monitored.
@End @SubSection

@SubSection
    @Title { Prefer times monitors }
@Begin
@LP
A prefer times monitor has tag @C { KHE_PREFER_TIMES_MONITOR_TAG }
and monitors an event which is one point of application of one
prefer times constraint.  Functions
@ID @C {
KHE_PREFER_TIMES_CONSTRAINT KhePreferTimesMonitorConstraint(
  KHE_PREFER_TIMES_MONITOR m);
KHE_EVENT KhePreferTimesMonitorEvent(KHE_PREFER_TIMES_MONITOR m);
}
return the prefer times constraint and event being monitored.
@PP
@C { KheMonitorAttachCheck } examines the domains of the meets
of @C { m }'s event whose durations are of interest to @C { m }'s
constraint.  If all of these domains are subsets of @C { m }'s
constraint's domain, then @C { m } may be detached.  A more refined
check would use the domains of the meets' leader meets, but
complications with offsets have ruled that out, at least for now.
@End @SubSection

@SubSection
    @Title { Split events monitors }
@Begin
@LP
A split events monitor has tag @C { KHE_SPLIT_EVENTS_MONITOR_TAG }
and monitors an event which is one point of application of one
split events constraint.  Functions
@ID @C {
KHE_SPLIT_EVENTS_CONSTRAINT KheSplitEventsMonitorConstraint(
  KHE_SPLIT_EVENTS_MONITOR m);
KHE_EVENT KheSplitEventsMonitorEvent(KHE_SPLIT_EVENTS_MONITOR m);
}
return the split events constraint and event being monitored.
@PP
Since the state of splitting is assumed by @C { KheMonitorAttachCheck }
to be fixed, all it needs to do here is ensure that @C { m } is attached,
then detach it if its cost is 0.  In this case there is no efficiency
gain from detaching @C { m }, since @C { m } only fires when events are
split and merged.
@End @SubSection

@SubSection
    @Title { Distribute split events monitors }
@Begin
@LP
A distribute split events monitor has tag
@C { KHE_DISTRIBUTE_SPLIT_EVENTS_MONITOR_TAG } and monitors
one point of application of a distribute split events constraint
(one event).  Functions
@ID @C {
KHE_DISTRIBUTE_SPLIT_EVENTS_CONSTRAINT
  KheDistributeSplitEventsMonitorConstraint(
  KHE_DISTRIBUTE_SPLIT_EVENTS_MONITOR m);
KHE_EVENT KheDistributeSplitEventsMonitorEvent(
  KHE_DISTRIBUTE_SPLIT_EVENTS_MONITOR m);
}
return the constraint and event being monitored.
@C { KheMonitorAttachCheck } behaves like it does for split events
monitors:  it first ensures that @C { m } is attached, then detaches
it if its cost is 0.
@End @SubSection

@SubSection
    @Title { Spread events monitors }
@Begin
@LP
A spread events monitor has tag @C { KHE_SPREAD_EVENTS_MONITOR_TAG }
and monitors an event group which is one point of application of a
spread events constraint.  It appears in the list of monitors of
all the events in its event group.  Functions
@ID @C {
KHE_SPREAD_EVENTS_CONSTRAINT KheSpreadEventsMonitorConstraint(
  KHE_SPREAD_EVENTS_MONITOR m);
KHE_EVENT_GROUP KheSpreadEventsMonitorEventGroup(
  KHE_SPREAD_EVENTS_MONITOR m);
}
return the spread events constraint and event group being monitored.
There are also
@ID { 0.96 1.0 } @Scale @C {
int KheSpreadEventsMonitorTimeGroupCount(KHE_SPREAD_EVENTS_MONITOR m);
void KheSpreadEventsMonitorTimeGroup(KHE_SPREAD_EVENTS_MONITOR m, int i,
  KHE_TIME_GROUP *time_group, int *minimum, int *maximum, int *incidences);
}
The first returns the number of time groups (as in the corresponding
constraint).  The second returns the @C { i }'th time group and the
minimum and maximum number of meets wanted there (again,
as in the constraint), plus the current number of meets
incident on that time group.  If @C { *incidences } is less than
@C { *minimum } or more than @C { *maximum }, a cost is incurred.
@End @SubSection

@SubSection
    @Title { Link events monitors }
@Begin
@LP
A link events monitor has tag @C { KHE_LINK_EVENTS_MONITOR_TAG }
and monitors an event group which is one point of application of
a link events constraint.  It appears in the list of monitors of
all the events in its event group.  Functions
@ID @C {
KHE_LINK_EVENTS_CONSTRAINT KheLinkEventsMonitorConstraint(
  KHE_LINK_EVENTS_MONITOR m);
KHE_EVENT_GROUP KheLinkEventsMonitorEventGroup(
  KHE_LINK_EVENTS_MONITOR m);
}
return the link events constraint and event group being monitored.
@PP
@C { KheMonitorAttachCheck } assumes that assignments of meets not
lying in nodes will not change for a long time.  For each meet of each
event monitored by @C { m } it forms a triple, consisting of the
duration of the meet, its leader meet as returned by @C { KheMeetLeader }
(Section {@NumberOf solutions.meets.assignment}), and its offset
into its leader meet.  If any triple cannot be built because some
meet has no leader meet, then @C { m } should remain attached.
Otherwise, if for each event @C { e } monitored by @C { m } the set
of triples formed from the meets derived from @C { e } is the
same, then @C { m } can be detached.
@PP
Detaching link events monitors is arguably the most important
service provided by @C { KheMonitorAttachCheck }.  This is
because keeping these monitors up to date is slow, despite the
author's best efforts to optimize.  When the times of a set of
linked events change together, the changes are reported one by
one to the monitor, forcing it through a tedious sequence of
cost modifications beginning and ending with 0.
@End @SubSection

@EndSubSections
@End @Section

@Section
    @Title { Event resource monitors }
    @Tag { monitoring.event_resource_monitors }
@Begin
@LP
An @I { event resource monitor } monitors one or more event resources.
The monitors (attached or unattached) which monitor a given event
resource may be visited by
@ID @C {
int KheEventResourceMonitorCount(KHE_SOLN soln, KHE_EVENT_RESOURCE er);
KHE_MONITOR KheEventResourceMonitor(KHE_SOLN soln,
  KHE_EVENT_RESOURCE er, int i);
}
The total cost of these monitors measures how well @C { er } is
timetabled.  Functions
@ID @C {
KHE_COST KheEventResourceCost(KHE_SOLN soln, KHE_EVENT_RESOURCE er);
KHE_COST KheEventResourceMonitorCost(KHE_SOLN soln,
  KHE_EVENT_RESOURCE er, KHE_MONITOR_TAG tag);
}
return the total cost of all the monitors monitoring @C { er }, and
the total cost of all monitors monitoring @C { er } of a specific
type, defined by @C { tag }.  @C { KheEventResourceMonitorCost }
returns 0 when @C { tag } does not specify one of the monitor types
in the following subsections.
@PP
Each point of application of an avoid split assignments constraint is a
whole set of event resources, and a monitor of this kind is attached to each
of the event resources in its set.  If @C { KheEventResourceCost(soln, er) }
is summed over all event resources, such a monitor is counted repeatedly,
so the total may exceed the total cost of all event resource monitors.
@PP
The following subsections list the various kinds of event resource
monitors and the details specific to each of them.  Their types
(@C { KHE_ASSIGN_RESOURCE_MONITOR } and so on) may be obtained by
downcasting from @C { KHE_MONITOR } after checking the type tag.
@BeginSubSections

@SubSection
    @Title { Assign resource monitors }
@Begin
@LP
An assign resource monitor has tag @C { KHE_ASSIGN_RESOURCE_MONITOR_TAG }
and monitors an event resource which is one point of application of
one assign resource constraint.  Functions
@ID @C {
KHE_ASSIGN_RESOURCE_CONSTRAINT KheAssignResourceMonitorConstraint(
  KHE_ASSIGN_RESOURCE_MONITOR m);
KHE_EVENT_RESOURCE KheAssignResourceMonitorEventResource(
  KHE_ASSIGN_RESOURCE_MONITOR m)
}
return the assign resource constraint and event resource being monitored.
@End @SubSection

@SubSection
    @Title { Prefer resources monitors }
@Begin
@LP
A prefer resources monitor has tag @C { KHE_PREFER_RESOURCES_MONITOR_TAG }
and monitors an event resource which is one point of application of one
prefer resources constraint.  Functions
@ID @C {
KHE_PREFER_RESOURCES_CONSTRAINT KhePreferResourcesMonitorConstraint(
  KHE_PREFER_RESOURCES_MONITOR m);
KHE_EVENT_RESOURCE KhePreferResourcesMonitorEventResource(
  KHE_PREFER_RESOURCES_MONITOR m);
}
return the prefer resources constraint and event resource being monitored.
@PP
For each task monitored by @C { m }, @C { KheMonitorAssignCheck } follows
the chain of assignments leading out of that task to the leader task.
These assignments, and the domain of the leader task, are assumed to be
unchanging.  If all the leaders' domains are subsets of the domain of
@C { m }'s constraint, then no assignments to leader tasks can violate
@C { m }, and @C { KheMonitorAssignCheck } ensures that @C { m } is
detached.  Otherwise it ensures that @C { m } is attached.
@End @SubSection

@SubSection
    @Title { Avoid split assignments monitors }
@Begin
@LP
The operations for building avoid split assignments constraints accept
a role and event groups, as required when reading XML.  However, they
also accept a set of event resources, and these are what are actually
used.  Accordingly, one avoid split assignments monitor monitors a
set of event resources, and appears in the list of monitors of each
of those event resources.  Functions
@ID -1.0px @Break @C {
KHE_AVOID_SPLIT_ASSIGNMENTS_CONSTRAINT
  KheAvoidSplitAssignmentsMonitorConstraint(
  KHE_AVOID_SPLIT_ASSIGNMENTS_MONITOR m)
int KheAvoidSplitAssignmentsMonitorEventGroupIndex(
  KHE_AVOID_SPLIT_ASSIGNMENTS_MONITOR m)
}
return the constraint and the index of the set of event resources
being monitored, suitable for passing to functions
@C { KheAvoidSplitAssignmentsConstraintEventResourceCount }
and @C { KheAvoidSplitAssignmentsConstraintEventResource }
(Section {@NumberOf avoid_split_assts}).  There are also
@ID @C {
int KheAvoidSplitAssignmentsMonitorResourceCount(
  KHE_AVOID_SPLIT_ASSIGNMENTS_MONITOR m);
KHE_RESOURCE KheAvoidSplitAssignmentsMonitorResource(
  KHE_AVOID_SPLIT_ASSIGNMENTS_MONITOR m, int i);
int KheAvoidSplitAssignmentsMonitorResourceMultiplicity(
  KHE_AVOID_SPLIT_ASSIGNMENTS_MONITOR m, int i);
}
The first returns the number of distinct resources currently assigned
to tasks monitored by @C { m }.  If @C { m } is a defect this number
will be at least 2.  The second and third return the @C { i }th of
these distinct resources (in an arbitrary order) and the number of
tasks monitored by @C { m } to which that resource is currently
assigned.  The monitor does not record which tasks those are.
@PP
For each task monitored by @C { m }, @C { KheMonitorAssignCheck }
follows the chain of assignments from the task to its leader task.
These chains are assumed to be unchanging.  If they all end at the
same leader task, then no assignments can violate @C { m }, and
@C { KheMonitorAssignCheck } ensures that @C { m } is detached.
Otherwise it ensures that @C { m } is attached.
@End @SubSection

@EndSubSections
@End @Section

@Section
    @Title { Resource monitors }
    @Tag { monitoring.resource_monitors }
@Begin
@LP
A @I { resource monitor } monitors a resource.  The set of monitors
(attached or unattached) which monitor a given resource may be
visited by calling
@ID @C {
int KheResourceMonitorCount(KHE_SOLN soln, KHE_RESOURCE r);
KHE_MONITOR KheResourceMonitor(KHE_SOLN soln, KHE_RESOURCE r, int i);
}
The total cost of these monitors measures how well @C { r } is
timetabled.  Functions
@ID @C {
KHE_COST KheResourceCost(KHE_SOLN soln, KHE_RESOURCE r);
KHE_COST KheResourceMonitorCost(KHE_SOLN soln, KHE_RESOURCE r,
  KHE_MONITOR_TAG tag);
}
return the total cost of all the monitors monitoring @C { r }, and
the total cost of all monitors monitoring @C { r } of a specific
type, defined by @C { tag }.  @C { KheResourceMonitorCost } returns
0 when @C { tag } does not specify one of the monitor types in the
following subsections.
@PP
The following subsections list the kinds of resource monitors
and their features.  Their types (@C { KHE_AVOID_CLASHES_MONITOR }
etc.) may be obtained by
downcasting from @C { KHE_MONITOR } after checking the type tag.
Monitors of type @C { KHE_WORKLOAD_DEMAND_MONITOR }, defined in
Section {@NumberOf matchings.workload}, are also visited by
@C { KheResourceMonitorCount } and @C { KheResourceMonitor }.
However, the timetable monitor for a resource is not visited by these
functions; as explained in Section {@NumberOf monitoring_timetables},
it is retrieved by calling @C { KheResourceTimetableMonitor }.
@BeginSubSections

@SubSection
    @Title { Avoid clashes monitors }
@Begin
@LP
An avoid clashes monitor has tag @C { KHE_AVOID_CLASHES_MONITOR_TAG }
and monitors a resource which is one point of application of one
avoid clashes constraint.  Functions
@ID -1.0px @Break @C {
KHE_AVOID_CLASHES_CONSTRAINT KheAvoidClashesMonitorConstraint(
  KHE_AVOID_CLASHES_MONITOR m);
KHE_RESOURCE KheAvoidClashesMonitorResource(
  KHE_AVOID_CLASHES_MONITOR m);
}
return the avoid clashes constraint and resource being monitored.
@End @SubSection

@SubSection
    @Title { Avoid unavailable times monitors }
@Begin
@LP
#An avoid unavailable times monitor has tag
This monitor has tag
@C { KHE_AVOID_UNAVAILABLE_TIMES_MONITOR_TAG } and monitors a resource
which is one point of application of one avoid unavailable times
constraint.  Functions
@ID -1px @Break @C {
KHE_AVOID_UNAVAILABLE_TIMES_CONSTRAINT
  KheAvoidUnavailableTimesMonitorConstraint(
  KHE_AVOID_UNAVAILABLE_TIMES_MONITOR m);
KHE_RESOURCE KheAvoidUnavailableTimesMonitorResource(
  KHE_AVOID_UNAVAILABLE_TIMES_MONITOR m);
}
return the avoid unavailable times constraint and resource being monitored.
@End @SubSection

@SubSection
    @Title { Limit idle times monitors }
@Begin
@LP
A limit idle times monitor has tag @C { KHE_LIMIT_IDLE_TIMES_MONITOR_TAG }
and monitors a resource which is one point of application of one limit
idle times constraint.  Functions
@ID -1px @Break @C {
KHE_LIMIT_IDLE_TIMES_CONSTRAINT KheLimitIdleTimesMonitorConstraint(
  KHE_LIMIT_IDLE_TIMES_MONITOR m);
KHE_RESOURCE KheLimitIdleTimesMonitorResource(
  KHE_LIMIT_IDLE_TIMES_MONITOR m);
}
return the limit idle times constraint and resource being monitored.
@End @SubSection

@SubSection
    @Title { Cluster busy times monitors }
@Begin
@LP
A cluster busy times monitor has tag @C { KHE_CLUSTER_BUSY_TIMES_MONITOR_TAG }
and monitors a resource which is one point of application of one
cluster busy times constraint.  Functions
@ID @C {
KHE_CLUSTER_BUSY_TIMES_CONSTRAINT KheClusterBusyTimesMonitorConstraint(
  KHE_CLUSTER_BUSY_TIMES_MONITOR m);
KHE_RESOURCE KheClusterBusyTimesMonitorResource(
  KHE_CLUSTER_BUSY_TIMES_MONITOR m);
}
return the cluster busy times constraint and resource being monitored.
@End @SubSection

@SubSection
    @Title { Limit busy times monitors }
@Begin
@LP
A limit busy times monitor has tag @C { KHE_LIMIT_BUSY_TIMES_MONITOR }
and monitors a resource which is one point of application of one limit
busy times constraint.  Functions
@ID @C {
KHE_LIMIT_BUSY_TIMES_CONSTRAINT KheLimitBusyTimesMonitorConstraint(
  KHE_LIMIT_BUSY_TIMES_MONITOR m);
KHE_RESOURCE KheLimitBusyTimesMonitorResource(
  KHE_LIMIT_BUSY_TIMES_MONITOR m);
}
return the limit busy times constraint and resource being monitored.
@End @SubSection

@SubSection
    @Title { Limit workload monitors }
    @Tag { monitoring_resource_monitors_workload }
@Begin
@LP
A limit workload monitor has tag @C { KHE_LIMIT_WORKLOAD_MONITOR }
and monitors a resource which is one point of application of one
limit workload constraint.  Functions
@ID @C {
KHE_LIMIT_WORKLOAD_CONSTRAINT KheLimitWorkloadMonitorConstraint(
  KHE_LIMIT_WORKLOAD_MONITOR m);
KHE_RESOURCE KheLimitWorkloadMonitorResource(
  KHE_LIMIT_WORKLOAD_MONITOR m);
float KheLimitWorkloadMonitorWorkload(KHE_LIMIT_WORKLOAD_MONITOR m);
}
return the limit workload constraint and resource being monitored,
and the current workload of that resource.
# @PP
# When the current specification of the limit workload constraint
# is examined from the point of view of incremental updating, it
# clearly has problems.  Accordingly, KHE implements a different
# specification, which, it is hoped, will become the official one
# in time.  The essence of the change is that each meet
# has an integer workload, chosen by the solver and represented
# by a new attribute of the meet in the XML file.  The
# choice is constrained by conditions which guarantee that the
# workload does not differ greatly from its `natural' value.  If
# there is no instance event, the workload is 0.  The workload
# of a resource is the sum of the workloads of the meets
# it is assigned to.  Appendix {@NumberOf workloads} has the details.
@End @SubSection

@EndSubSections
@End @Section

@Section
    @Title { Timetable monitors }
    @Tag { monitoring_timetables }
@Begin
@LP
A @I { timetable } is a record of what is going on at each time.
As part of monitoring cost, KHE monitors the timetable of each
resource and each event.  Function
@ID @C {
KHE_TIMETABLE_MONITOR KheResourceTimetableMonitor(KHE_SOLN soln,
  KHE_RESOURCE r);
}
returns the timetable monitor of resource @C { r }, and
@ID @C {
KHE_TIMETABLE_MONITOR KheEventTimetableMonitor(KHE_SOLN soln,
  KHE_EVENT e);
}
returns the timetable monitor of event @C { e }.  Type
@C { KHE_TIMETABLE_MONITOR } is a subtype of type @C { KHE_MONITOR }
with tag @C { KHE_TIMETABLE_MONITOR_TAG }.  The cost of a timetable
monitor is always 0, so it never appears in any list of defects.
@PP
A particular set of meets is known to a timetable monitor at any
moment.  For a resource timetable monitor it is the set of meets
that are assigned both a time and the resource.  For an event
timetable monitor it is the set of meets derived from the event
that are assigned a time.  The monitor offers these operations,
which report which meets are running at each time:
@ID { 0.98 1.0 } @Scale @C {
int KheTimetableMonitorTimeMeetCount(KHE_TIMETABLE_MONITOR tm,
  KHE_TIME time);
KHE_MEET KheTimetableMonitorTimeMeet(KHE_TIMETABLE_MONITOR tm,
  KHE_TIME time, int i);
}
@C { KheTimetableMonitorTimeMeetCount } returns the number of
known meets running at @C { time }, and
@C { KheTimetableMonitorTimeMeet } returns the @C { i }th
of these meets.
@PP
A timetable monitor offers no operations which report its set of meets
directly.  For event timetables one can use @C { KheEventMeetCount }
and @C { KheEventMeet } from Section {@NumberOf solutions.objects} to
obtain the meets derived from a particular event; the timetabled meets
are just those with an assigned time.  For resource timetables one can
use @C { KheResourceAssignedTaskCount } and @C { KheResourceAssignedTask }
from Section {@NumberOf solutions.tasks.asst} to obtain all the tasks
assigned the resource; the timetabled ones are just those whose
enclosing meet has an assigned time.
@PP
As usual, timetable monitors are created by @C { KheSolnMake } and
exist for as long as the solution does.  There is one for each
resource, and one for each event.  Unlike other monitors, however,
timetable monitors are not attached initially.  It is possible for
the timetable returned by @C { KheResourceTimetableMonitor } or
@C { KheEventTimetableMonitor } to be unattached and so not up
to date (it will be empty in this case).  It can be brought up to
date by attaching it.
@PP
All resource monitors except limit workload monitors depend on
resource timetable monitors.  Link events monitors (but not spread
events monitors) depend on event timetable monitors.  When one of
these monitors is attached, the timetable monitor(s) it depends
on are also attached.  Thus, to begin with, timetable monitors
are attached only as needed by other monitors.  Detaching a
timetable monitor causes KHE to abort unless no attached monitors
depend on it.
@PP
Although it would make sense to treat a timetable as a group
monitor, that elegant option is not offered.  The user who wants
all the problems associated with a single resource or event to
be channelled through a single monitor must create a group
monitor, separate from the timetable, and add the appropriate
monitors to it in the usual way.
@PP
Timetable monitors may be debugged by calling @C { KheMonitorDebug }
as usual.  And
@ID @C {
void KheTimetableMonitorPrintTimetable(KHE_TIMETABLE_MONITOR tm,
  int cell_width, int indent, FILE *fp);
}
prints a conventional tabular timetable, using @C { Days } and
possibly @C { Weeks } time groups from the instance to determine
its shape.  Parameter @C { cell_width } is the width of each cell,
in characters.
@End @Section

@Section
    @Title { Monitor updating }
    @Tag { monitoring_propagation }
@Begin
@LP
When the user executes an operation that changes the state of a
solution, KHE works out the revised cost.  For efficiency, this
must be done incrementally.  This section explains how it is
done---but just for information:  the functions defined here
cannot be called by the user.
@PP
The monitors are linked into a network that allows state changing
operations to flow naturally to where they need to go.  Only
attached monitors are linked in; detached ones are removed, so
that no time is wasted on them.  The full list of basic operations
that affect cost is
@ID @Tbl
  aformat { @Cell ml { 0i } A | @Cell B | @Cell mr { 0i } C }
{
@Rowa
    A { @C {
KheMeetMake
KheMeetDelete
KheMeetSplit
} }
    B { @C {
KheMeetMerge
KheMeetAssign
KheMeetUnAssign
} }
    C { @C {
KheTaskMake
KheTaskDelete
KheTaskAssign
KheTaskUnAssign
} }
}
Six originate in @C { KHE_MEET } objects, four in
@C { KHE_TASK } objects.  From there their impulses flow
to objects of three private types:
@CD @OneRow 0.95 @Scale @Diag linklabelbreak { ragged -4px } {
@Tbl
    indent { ctr }
    aformat { @Cell ml { 0i } mr { 6c } A | @Cell mr { 0i } B }
{
@Rowa
    ma { 3c }
    A { SE::  @Box @C { KHE_MEET } }
    B { ES::  @Box @C { KHE_EVENT_IN_SOLN } }
@Rowa
    mv { 2c }
    A { SR::  @Box @C { KHE_TASK } }
    B { ERS:: @Box @C { KHE_EVENT_RESOURCE_IN_SOLN } }
@Rowa
    B { RS::  @Box @C { KHE_RESOURCE_IN_SOLN } }
}
//
@Arrow from { SE@NW ++ {0 1c} } to { SE }
  xlabel { @C {
KheMeetMake
KheMeetDelete
KheMeetSplit
KheMeetMerge
KheMeetAssign
KheMeetUnAssign
  } }
@Arrow from { SE } to { SR }
  ylabel { @C {
Split
Merge
AssignTime
UnAssignTime
  } }
@Arrow from { SE } to { ES }
  ylabel { @C {
Add
Delete
Split
Merge
AssignTime
UnAssignTime
  } }
@Arrow from { SR } to { ERS }
  ylabel { @C {
Add
Delete
Split
Merge
AssignResource
UnAssignResource
  } }
@Arrow from { SR } to { RS }
  ylabelmargin { 0i }
  ylabelprox { below }
  ylabeladjust { 0.2c 0.5c }
  ylabel { @C {
Split
Merge
AssignTime
UnAssignTime
AssignResource
UnAssignResource
  } }
@Arrow from { SR@SW -- {0 1c} } to { SR }
  xlabelprox { below }
  xlabel { @C {
KheTaskMake
KheTaskDelete
KheTaskAssign
KheTaskUnAssign
} }
}
@C { KHE_EVENT_IN_SOLN } holds information about one event in a
solution:  the meets derived from it (where
@C { KheEventMeet } gets its values from), a list of `event
resource in solution' objects, one for each of its event resources,
and a list of monitors, possibly including a timetable
(timetables are monitors).  @C { KHE_EVENT_RESOURCE_IN_SOLN }
holds information about one event resource in a solution:  the
tasks derived from it, and a list of monitors.
@C { KHE_RESOURCE_IN_SOLN } holds information about one resource
in a solution:  the tasks it is currently assigned to,
and a list of monitors, usually including a timetable.
@PP
The connections are fairly self-evident.  For example, if
@C { KheMeetMake } is called to make a meet derived from a given
instance event, then that event's event in solution object needs
to know this, and the @C { Add } operation (full name
@C { KheEventInSolnAddMeet }) informs it.  @C { KheMeetAssign }
only generates an @C { AssignTime } call when the assignment links
the meet, directly or indirectly, to a cycle meet, assigning a time
to it.  Event resource in solution objects are not told about time
assignments and unassignments.  Calls only pass from a task object
@C { task } to a resource in solution object when @C { task } is
assigned a resource.
@PP
The connections leading out of @C { KHE_EVENT_IN_SOLN } are as follows:
@CD @OneRow @Diag linklabelbreak { ragged -4px } {
@Tbl
    indent { ctr }
    aformat { @Cell ml { 0i } mr { 3c } A | @Cell mr { 0i } B }
{
@Rowa
    ma { 0.0c }
    A { ES::  @Box @C { KHE_EVENT_IN_SOLN } }
@Rowa
    ma { 1.5c }
    B { SEM:: @Box @C { KHE_SPLIT_EVENTS_MONITOR } }
@Rowa
    B { DSEM:: @Box @C { KHE_DISTRIBUTE_SPLIT_EVENTS_MONITOR } }
@Rowa
    B { ATM::  @Box @C { KHE_ASSIGN_TIME_MONITOR } }
@Rowa
    B { PTM::  @Box @C { KHE_PREFER_TIMES_MONITOR } }
@Rowa
    B { TT:: @Box @C { KHE_TIMETABLE_MONITOR } }
@Rowa
    B { SPEM:: @Box @C { KHE_SPREAD_EVENTS_MONITOR } }
    mb { 0.0c }
}
//
@VHArrow from { ES@SE -- {0.5c 0} } to { SEM }
  xlabel { @C {
Add
Delete
Split
Merge
  } }
@VHArrow from { ES@SE -- {0.5c 0} } to { DSEM }
@VHArrow from { ES@SW ++ {0.5c 0} } to { ATM }
  xlabel { @C {
Add
Delete
Split
Merge
AssignTime
UnAssignTime
  } }
@VHArrow from { ES@SW ++ {0.5c 0} } to { PTM }
@VHArrow from { ES@SW ++ {0.5c 0} } to { TT }
@VHArrow from { ES@SW ++ {0.5c 0} } to { SPEM }
}
Split events and distribute split events monitors do not need to
know about time assignment and unassignment.  Based on the calls
they receive, they keep track of meet durations and
report cost accordingly.  Assign time and prefer times monitors
are even simpler; they report cost depending on whether the
meets reported to them are assigned times or not.
@PP
Event timetables are used by link events constraints, which need
to know the times when the event's meets are running,
ignoring clashes, which is just what timetables offer.
@PP
A spread events monitor is connected to the event in solution
objects corresponding to each of the events it is interested in.
It keeps track of how many meets from those events
collectively have starting times in each of its time groups, and
calculates deviations accordingly.  Spread events monitors are
not attached to timetables because, although their monitoring is
similar, there are significant differences:  spread events
monitor time groups come with upper and lower limits, making
them not sharable in general, and the quantity of interest is the
number of distinct meets that intersect each time group,
not the number of busy times calculated by the time group monitors
attached to timetables.
# @PP
# It might seem that spread events monitors could usefully be
# attached to timetables rather than directly to event in solution
# objects, especially since they analyse by time groups, which
# timetables supply in the form of time group monitors (see below).
# However, a closer look shows two significant differences:  spread
# events monitor time groups come with upper and lower limits,
# making them not sharable in general, and the quantity of interest
# is the number of distinct meets that intersect each time
# group (either in their starting times or at all), which is quite
# different from the number of busy times calculated by time group
# monitors.  In the end it seemed best to keep spread events monitors
# completely separate.
@PP
The connections leading out of @C { KHE_EVENT_RESOURCE_IN_SOLN } are
@CD @OneRow @Diag linklabelbreak { ragged -4px } {
@Tbl
    indent { ctr }
    aformat { @Cell ml { 0i } mr { 1.5c } A | @Cell mr { 0i } B }
{
@Rowa
    ma { 0.0c }
    A { ERS::  @Box @C { KHE_EVENT_RESOURCE_IN_SOLN } }
@Rowa
    ma { 2.5c }
    B { ARM:: @Box @C { KHE_ASSIGN_RESOURCE_MONITOR } }
@Rowa
    B { PRM:: @Box @C { KHE_PREFER_RESOURCES_MONITOR } }
@Rowa
    B { ASAM::  @Box @C { KHE_AVOID_SPLIT_ASSIGNMENTS_MONITOR } }
    mb { 0.0c }
}
//
@VHArrow from { ERS } to { ARM }
  xlabel { @C {
Add
Delete
Split
Merge
AssignResource
UnAssignResource
  } }
@VHArrow from { ERS } to { PRM }
@VHArrow from { ERS } to { ASAM }
}
None of these monitors cares about time assignments and unassignments.
Assign resource monitors and prefer resources monitors are very simple,
reporting cost depending on whether the tasks passed to
them are assigned or not.
@PP
An avoid split assignments monitor is connected to one event resource
in solution object for each event resource in its point of application.
It keeps track of a multiset of resources, one element for each assignment
to each task it is monitoring, and its cost depends on the
number of distinct resources in that multiset.
@PP
The connections leading out of @C { KHE_RESOURCE_IN_SOLN } are
@CD @OneRow @Diag linklabelbreak { ragged -4px } {
@Tbl
    indent { ctr }
    aformat { @Cell ml { 0i } mr { 1.5c } A | @Cell mr { 0i } B }
{
@Rowa
    ma { 0.0c }
    A { RS::  @Box @C { KHE_RESOURCE_IN_SOLN } }
@Rowa
    ma { 1.2c }
    B { LWM:: @Box @C { KHE_LIMIT_WORKLOAD_MONITOR } }
@Rowa
    B { TT:: @Box @C { KHE_TIMETABLE_MONITOR } }
    mb { 0.0c }
}
//
@VHArrow from { RS@SE -- {0.5c 0} } to { LWM }
  xlabel { @C {
AssignResource
UnAssignResource
  } }
@VHArrow from { RS@SW ++ {0.5c 0} } to { TT }
  xlabel { @C {
Split
Merge
AssignTime
UnAssignTime
AssignResource
UnAssignResource
  } }
}
Limit workload constraints do not need to know about time assignments,
evidently, but they also do not need to know about splits and merges,
since these do not change the total workload.
@PP
Calculating workloads is then very simple.  Each meet
receives a workload when it is created, and when a resource is
assigned, the workload limit monitors attached to its resource in
solution object are updated, and pass revised costs to the solution.
@PP
@C { KHE_TIMETABLE_MONITOR } receives many kinds of calls, some from
@C { KHE_EVENT_IN_SOLN } and others from @C { KHE_RESOURCE_IN_SOLN }.
However, since it monitors the timetable of a set of meets
with assigned times, all these can be mapped to just two incoming
operations, which we call @C { AddMeetAtTime } and
@C { DeleteMeetAtTime }.  For example, a split maps to one
@C { DeleteMeetAtTime } and two @C { AddMeetAtTime }
calls.  The outgoing operations are
@CD @OneRow @Diag linklabelbreak { ragged -4px } {
@Tbl
    indent { ctr }
    aformat { @Cell ml { 0i } mr { 1.5c } A | @Cell mr { 0i } B }
{
@Rowa
    ma { 0.0c }
    A { TT:: @Box { 0.8c @Wide {} & @C { KHE_TIMETABLE_MONITOR } & 0.8c @Wide {} } }
@Rowa
    ma { 0.6c }
    B { ACM:: @Box @C { KHE_AVOID_CLASHES_MONITOR } } 
@Rowa
    B { LEM:: @Box @C { KHE_LINK_EVENTS_MONITOR } }
@Rowa
    B { TGM:: @Box @C { KHE_TIME_GROUP_MONITOR } }
    mb { 0.0c }
}
//
@VHArrow from { TT@SE -- {0.5c 0} } to { ACM }
  xlabel { @C {
ChangeClashCount
Flush
  } }
@VHArrow from { TT@SW ++ {0.5c 0} } to { LEM }
  xlabel { @C {
AssignTimeNonClash
UnAssignTimeNonClash
Flush
  } }
@VHArrow from { TT@SW ++ {0.5c 0} } to { TGM }
}
An avoid clashes monitor is notified whenever the number of meets
at any one time increases to more than 1 or decreases from more than 1
(operation @C { ChangeClashCount } above).  It uses these notifications
to maintain a set of deviations.  As an optimization, when the cost
function is Sum it maintains only the total number of deviations.  It
updates the solution when a @C { Flush } is received from the timetable
at the end of the operation.
@PP
The other monitors are attached to the timetable at each time they are
interested in, and are notified when one of those times becomes busy
(when its number of meets increases from 0 to 1) and when it
becomes free (when its number of meets decreases from 1 to 0),
by operations @C { AssignTimeNonClash } and @C { UnAssignTimeNonClash }
above.
@PP
A link events monitor is interested in all the times of all the
timetables of the events in its point of application.  It is
notified when any of these times becomes busy or free, and
uses that information to maintain, for each time, the number
of its events that are busy at each time.  Its number of
deviations, also maintained incrementally, is the number of
times where some of its events, but not all of them, are running.
# @FootNote {
# KHE offers a simple way to ensure that a link events constraint is
# never violated, assuming that all the events to be linked have the
# same duration.  Let the events to be linked be
# @M { e sub 1 , e sub 2 ,..., e sub n }, and
# suppose that their common duration is @M { d }.
# At the start of the solve, split each @M { e sub i } into @M { m }
# meets @M { s sub i1 , s sub i2 ,..., s sub im } of durations
# (in order) @M { d sub 1 , d sub 2 ,..., d sub m }, whose sum is
# @M { d }.  The choice of @M { m } and the @M { d sub j } will be
# informed by the split events and distribute split events constraints
# applicable to the @M { e sub i }, and is a separate matter.
# Suppose that @M { m } distinct @I { leader meets }
# @M { l sub 1 , l sub 2 ,..., l sub m } can be found such that:
# @BulletList
# 
# @LI {
# For all @M { j }, the duration of @M { l sub j } is at least
# @M { d sub j };
# }
# 
# @LI {
# For all @M { j }, if @M { l sub j = s sub ij } for some @M { i },
# then all the other @M { s sub ij } are assigned to @M { l sub j }
# at the same offset (0 in this case);
# }
# 
# @LI {
# For all @M { j }, if @M { l sub j != s sub ij } for any @M { i },
# then @M { l sub j } is not equal to any meet of any
# @M { e sub i }, and all the @M { s sub ij } are assigned to
# @M { l sub j } at the same offset (not necessarily 0).
# }
# 
# @EndList
# Then, as long as the assignments in those @M { s sub ij } that are
# not leaders remain in place, even if no times are assigned it is
# already clear that no violations of the link events constraint are
# possible, because the assignment of a time to a leader meet of
# duration @M { d sub j } assigns the same time to one meet of
# duration @M { d sub j } of every @M { e sub i }.  In these cases, the 
# link events monitors concerned should be detached.  They are expensive
# to keep up to date, yet only ever report cost 0.
# @PP
# @I { Not yet implemented. }  To support this style of solving,
# KHE offers @I { link locking }.  The user may request that a
# given link events monitor be link locked.  This causes KHE to
# verify that the current state of the assignments of the solution
# events of the events being monitored is as described above,
# including identifying a set of leader meets.  It
# then locks all the assignments in the non-leaders (i.e. makes it a
# fatal error to attempt to remove them), and detaches the link events
# monitor, so that no time will be wasted on it.
# Although a link
# lock can be removed at any time, link locking and unlocking are
# fairly slow operations.  Applying one link lock to each link events
# monitor at the start of the solve is fine, but frequent locking
# and unlocking during the solve, although legal, is not recommended.
# }
@PP
A time group monitor monitors one time group within one timetable.
It is attached to its timetable at the times of its time group, so
is notified when one of those times becomes busy or free.  It keeps
track of the number of busy and idle times in its time group.
@PP
As an optimization, the number of idle times is calculated only when
at least one limit idle times monitor is attached to the time group
monitor; otherwise the number is taken to be 0.  A bit vector @M { V },
holding the positions of the busy times in the time group being monitored,
is maintained.  When the monitor is flushed, the number of idle times
of @M { V } is calculated as follows.  If @M { V } is empty, there are
no idle times.  Otherwise, the number of idle times is
@ID @Math { max(V) - min(V) + 1 - "|" V "|" }
The first three terms give the total number of times from the
first busy time to the last inclusive; every non-busy time
within that range is an idle time and conversely.
@PP
@M { "|" V "|" } is just the number of busy times, always
maintained by the time group monitor, so it is readily available.
The calculation of @M { min(V) } and @M { max(V) } on a bit
vector is a well-known problem which never seems to attract
adequate hardware support.  KHE's bit vector module calculates
@M { min(V) } by a linear search for the first non-zero word
of the bit vector, followed by a linear search for the first
non-zero byte of that word, and finishing with a lookup in a
256-word table, indexed by that byte, which returns the position
of the first non-zero bit of that byte.  The same method,
searching in the other direction, finds @M { max(V) }.
@PP
Old and new values for the number of busy and idle times are
stored, and when a flush is received they are propagated
onwards via operation @C { ChangeBusyAndIdle }:
@CD @OneRow @Diag linklabelbreak { ragged -4px } {
@Tbl
    indent { ctr }
    aformat { @Cell ml { 0i } mr { 1.5c } A | @Cell mr { 0i } B }
{
@Rowa
    ma { 0.0c }
    A { TGM:: @Box @C { KHE_TIME_GROUP_MONITOR } }
@Rowa
    ma { 1.0c }
    B { AUTM:: @Box @C { KHE_AVOID_UNAVAILABLE_TIMES_MONITOR } }
@Rowa
    B { LITM:: @Box @C { KHE_LIMIT_IDLE_TIMES_MONITOR } } 
@Rowa
    B { CBTM:: @Box @C { KHE_CLUSTER_BUSY_TIMES_MONITOR } }
@Rowa
    B { LBTM:: @Box @C { KHE_LIMIT_BUSY_TIMES_MONITOR } }
    mb { 0.0c }
}
//
@VHArrow from { TGM } to { AUTM }
  xlabel { @C {
AddBusyAndIdle
DeleteBusyAndIdle
ChangeBusyAndIdle
  } }
@VHArrow from { TGM } to { LITM }
@VHArrow from { TGM } to { CBTM }
@VHArrow from { TGM } to { LBTM }
}
When a monitor is attached, function @C { AddBusyAndIdle } is called
instead, and when a monitor is detached, function @C { DeleteBusyAndIdle }
is called instead.
@PP
An unavailable times monitor is connected to a time group monitor
monitoring the unavailable times.  It receives an updated number
of busy times from @C { ChangeBusyAndIdle } and reports any
change of cost to the solution.
@PP
A limit idle times monitor is connected to the time group
monitors corresponding to the time groups of its constraint.
It receives updated idle counts from each of them, and based
on them it maintains a count of deviations.
@PP
A cluster busy times monitor is also connected to the time
group monitors corresponding to the time groups of its
constraint.  It is interested in whether the busy counts it
receives from them change from zero to non-zero, or conversely.
@PP
A limit busy times monitor is also connected to the time
group monitors corresponding to the time groups of its
constraint.  It receives updated busy counts from each of
them, and based on them it maintains a set of deviations,
or just a total if its constraint's cost function is Sum.
@End @Section

@EndSections
@End @Chapter
